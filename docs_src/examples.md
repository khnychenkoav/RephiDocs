
# Примеры использования Rephi

Ниже приведены примеры кода, которые вы можете запустить в REPL (важно учесть, что REPL требует однострочную запись команд) или сохранить в файл `.re` для пакетного выполнения.

---

## 1. Факториал и вывод через pipeline

```re
# Определение факториала
let rec fact = \n ->
    if n == 0 then 1
    else n * fact (n - 1)

# Вычисление и вывод результата
5 |> fact |> println
```

**Результат в REPL:**

```
rephi> 5 |> fact |> println
120
```

---

## 2. Map и Filter над списком

```re
# Создаём явный список чисел
let numbers = [1,2,3,4,5,6,7,8,9,10]

# Умножаем каждый элемент на 3 и фильтруем > 15
numbers
  |> map (\x -> x * 3)
  |> filter (\x -> x > 15)
  |> println
```

**Ожидаемый вывод:**

```
[18,21,24,27,30]
```

---

## 3. Определение функции с помощью `func … end`

```re
# Определяем функцию сложения двух чисел
func add(a, b)
    return a + b
end

# Вызываем и выводим
println (add 10 20)
```

**Вывод в REPL:**

```
30
```

---

## 4. Ленивые вычисления: `lazylet` и `force`

```re
# Объявляем ленивую переменную x
lazylet x = (
    println 100   # распечатывает 100 и возвращает 100
    |> (\n -> n * 2)
)

# Ещё нет вычисления — ничего не напечатано

# Первый force: вычисление и печать
force x |> println
# Второй force: возвращается кешированное значение без повторного println
force x |> println
```

**Пример вывода:**

```
100   # из println внутри ленивой инициализации при первом force
200   # результат первого force
200   # кешированное значение второго force
```

---

## 5. Работа с файлами (File I/O)
Важно: Rephi поддерживает работу с файлами и через readFile, writeFile, но мы настоятельно рекомендуем использовать readfl, writefl для лучшей совместимости с новыми версиями языка.
```re
# Записываем число 456 в файл с «именем» 1
writefl 1 456

# Читаем содержимое файла 1 и выводим длину
readfl 1 |> println
```

---

## 6. Операции над списками: head, tail, pop

```re
let lst = [10,20,30,40]

# Первый элемент
head lst |> println

# Операция разворота списка (требует захвата конкретного элемента)
lst |> tail |> |> head |>println

# Список без первого
lst |> pop |> println
```

---

