
# Архитектура реализации Rephi

Rephi построен по классической многоступенчатой схеме: лексер → парсер → (дешугаринг) → eval → рантайм → интерфейс взаимодействия (REPL или batch). Ниже — подробное описание каждого компонента.

---

## 1. Лексер (`src/lexer.c`)

* Однопроходный анализ UTF‑8-строки: функции `lexer_init` и `lexer_next`
* Пропуск пробельных символов, поддержка комментариев `#…` и `--…`
* Опознаёт токены:

  * Литеры целых чисел (`TOK_INT`)
  * Идентификаторы (`TOK_IDENT`) и символьные идентификаторы (`TOK_SYM_IDENT`)
  * Ключевые слова (`if`, `then`, `else`, `let`, `rec`, `func`, `end`, `return`, `lazy`, `force`, `lazylet`)
  * Операторы `+ - * / == = \ |> ( ) [ ] ,`
* Ключевые таблицы:

  * `kw_table[]` для поиска ключевых слов (строгое сравнение по длине)
  * Символьные операторы: набор `!$%&*+./:<=>?@^|-~`
* При столкновении с неизвестным символом возвращает `TOK_UNKNOWN`

---

## 2. Парсер (`src/parser.c`)

Реализован Pratt-парсер с учётом приоритетов операторов:

1. **parse\_primary** — первичные выражения:

   * Литеры и идентификаторы
   * Лямбда-абстракции (`\params -> body`)
   * `if`-выражения
   * `lazy`, `force`, `lazylet`
   * `let` / `let rec`
   * Cписки `[1,2,3]` вёрсткой через `cons`/`nil`
   * Группировка в скобках
2. **parse\_expr** — петля обработки инфиксных операторов:

   * Поиск следующего токена, определение его binding power (`precedence`)
   * Разбор `|>` как специального пайплайн-оператора (меняет порядок применения)
   * Встраивание пользовательских символьных операторов через `TOK_SYM_IDENT`
   * Создание узлов AST (`make_binary`, `make_apply`)

Построенный AST описывается в `include/ast.h` (перечисление `NodeTag`, структура `Expr`).


---

## 3. Eval (Krivine‑машина) (`src/eval.c`)

Главная функция — `eval_value(const Expr *e, name_table *nt)`, возвращающая `Value*`.

* **AST\_INT / AST\_IDENT** → создаются `VAL_INT` и поиск в `name_table`
* **Арифметические узлы** (`AST_ADD`, `AST_SUB`, `AST_MUL`, `AST_DIV`) → проверка целочисленных аргументов, вычисление
* **AST\_EQ, AST\_IF** → сравнение и ветвление по `int` (0/1)
* **AST\_LAMBDA** → `val_closure` сохраняет параметр, тело и текущий контекст (`name_table_top_context`)
* **AST\_APPLY**:

  * Оптимизация цепочек вызовов: `flatten_apply` + поддержка `VAL_FUNC` (блоки `func ... end`)
  * Прямые C-примитивы (`VAL_PRIM`) вызываются немедленно
  * Стандартное применение для `VAL_CLOSURE`: загрузка контекста, новый блок (`let`), подстановка аргумента
* **Ленивость**:

  * `AST_LAZY` → `val_thunk`, сохраняющий `Expr*`, контекст и необработанное значение для кеширования
  * `AST_FORCE` → вычисление thunk при первом `force`, кеширование результата
  * `AST_LAZYLET` → объявление ленивой переменной в таблице имён без немедленного вычисления
* **AST\_RETURN** → поднимает специальный `VAL_RETURN` для реализации досрочного выхода из функции

Непосредственно многопараметрочные функции организованы через связный список `ValueNode*`.

---

## 4. Рантайм (`src/runtime.c`)

Регистрация примитивов в `name_table`:

* **print**  — вывод `Int` в stdout
* **readLine** — чтение строки из stdin, возвращает длину
* **readFile** — чтение файла по числовому имени, возвращает длину
* **writeFile** — двухфазная функция: сначала `val_prim(writefile_second)`, затем запись числа как байтов

Аргументы примитивов всегда упакованы в `Value*`.

---

## 5. Интерфейс взаимодействия

### 5.1 REPL (`src/repl.c`)

* Инициализация: `name_table_init`, `register_primitives`, `load_stdlib`
* Чтение строк из stdin, парсинг и вызов `eval`, вывод `long`
* Цикл до EOF (Ctrl+D)

### 5.2 Batch-mode (`src/interpretator.c`)

* Построчный разбор с поддержкой специальных команд:

  * `func имя(args...) ... return ... end` — объявление функций
  * Все остальные строки — обычные Rephi-выражения (`parse` + `eval_value`)
* Хранение функций как `Value->func.firstLine` (список `FuncLine*`)

---

## 6. Управление памятью

* **Выделение** через `malloc` для всех узлов AST, `Env`, `Value`
* **Освобождение**:

  * `free_expr` рекурсивно удаляет AST
  * `free_env` рекурсивно освобождает цепочку `Env`
  * `free_name_table` чистит все блоки таблицы имён и окружения

---

## 7. Таблица имён (`src/name_table.c`)

Реализована как стек `name_table_block`:

* Поле `block_head` — указатель на связанный список `Env` с именами и значениями
* `next_block` — предыдущий блок в стеке лексических областей
* `next_context` — ссылка на начало захваченного контекста (для замыканий и thunk)

Основные операции:

* `name_table_init` — создание глобального блока
* `name_table_add` — добавление имени в текущий блок (ошибка при повторном объявлении)
* `name_table_lookup` — поиск в цепочке контекстов
* `name_table_push_block(nt, newContext)` / `name_table_pop_block(nt)` — открытие/закрытие областей видимости
* `name_table_top_context` — сбор «среза» контекста для замыкания
* `name_table_load_context` / `name_table_pop_context` — временное переключение на сохранённый контекст при вызове лямбд

---

