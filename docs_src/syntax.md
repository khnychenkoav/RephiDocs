
# Синтаксис языка Rephi

Ниже приведён полный обзор синтаксиса языка

## 1. Лексика

* **Пробелы и отступы**: пропускаются (в том числе табуляции и перевод строки).
* **Комментарии**:

  * `# ...` до конца строки
  * `-- ...` до конца строки
* **Литералы**:

  * Целые числа: последовательность цифр, например `0`, `123`, `42`.
* **Идентификаторы**:

  * Начинаются с буквы `[A-Za-z]` или `_`, могут содержать буквы, цифры и `_`.
  * Примеры: `x`, `foo`, `_tmp1`, `map2`.
* **Символьные идентификаторы** (infix-операторы):

  * Любая непустая последовательность символов из набора `!$%&*+./:<=>?@^|-~`.
  * Пример: `**`, `>>=`, `++`, `$`.
* **Ключевые слова**:

  * `if`, `then`, `else`, `let`, `in`, `rec`, `func`, `end`, `return`, `lazy`, `force`, `lazylet`.
* **Операторы и разделители**:

  * `+  -  *  /  ==  =  \  |>  (  )  [  ]  ,` и другие символы для infix-операторов.

## 2. Приоритеты операторов

Перед использованием операторов важно понять, что Rephi пердназначен в первую очередь для обучения и по этой причине на текущей версии поддерживает только работу (в особенности ввод и вывод) с целыми числами

Все операторы лево‑ассоциативны. Приоритет (от 0 до 60):

| Оператор                                      | Приоритет |
| --------------------------------------------- | --------- |
| `*`, `/`                                      | 60        |
| `+`, `-`                                      | 50        |
| `==`                                          | 40        |
| `|>`       | 20 |
| **Пользовательские символьные** (`SYM_IDENT`) | 55        |
| **Применение (function call)**                | 70        |

Применение функций (например `f x y`) имеет самый высокий приоритет.

## 3. Основные конструкции

### 3.1. Литералы и идентификаторы

```re
42
foo_bar
```

### 3.2. Применение (Function application)

Вызов функции — простая последовательность выражений.

```re
f x y  # эквивалентно (f x) y
```

### 3.3. Лямбда-выражения

Синтаксис: `\param -> тело`.

```re
\x -> x + 1
\x y -> x * y   # эквивалентно \x -> (\y -> x*y)
```

### 3.4. Let и Let rec

* **Let**: `let имя = выражение in тело`.
* **Let rec**: `let rec имя = выражение in тело` (внутри `expression` должно быть лямбда).

```re
let x = 10 in x * 2
let rec fact = \n -> if n == 0 then 1 else n * fact (n - 1) in fact 5
```

### 3.5. Условное выражение

```re
if cond then expr1 else expr2
```

### 3.6. Списковые литералы

* **Явный список**:

  ```
  [1, 2, 3]
  ```

  Порождается через вложенные вызовы `cons`/`nil`с применением кодирования Черча.


### 3.7. Pipeline-оператор

Синтаксис: `expr1 |> expr2` эквивалентен `expr2 expr1` (приоритет 20).

```re
[1,2,3] |> map (\x -> x*2) |> filter (> 3)
```

### 3.8. Ленивость: `lazy`, `force`, `lazylet`

* **`lazy expr`** — создаёт thunk, вычисление отложено.
* **`force expr`** — запускает thunk и возвращает значение (с кешированием).
* **`lazylet x = expr`** — объявляет ленивую переменную `x`, аналогично `let`, но вычисление отложено до `force` или явного использования.

```re
lazylet z = expensive_calculation
... use z ...
force z
```

### 3.9. Определение функций в скриптах

```re
func имя(arg1, arg2, ...)     # начало определения
   ... тело: произвольные Rephi-выражения
return expr                    # необязательно, для досрочного выхода
end                            # конец определения
```

После чего функция доступна как обычный идентификатор.

## 4. Пример полного выражения

```re
# Вычисляем факториал 5 и выводим через пайплайн
let rec fact = \n -> if n == 0 then 1 else n * fact (n-1) in 5 |> fact |> print
```

